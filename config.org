* Initialize
#+begin_src elisp
(message "Initializing...")
(message "********************************************************************************")

;; Initialize package sources
(require 'package)

(setq package-archives '(("melpa" . "https://melpa.org/packages/")
			 ;; ("org" . "https://orgmode.org/elpa")
			 ("elpa" . "https://elpa.gnu.org/packages/")))

(package-initialize)

(unless package-archive-contents
  (package-refresh-contents))

(unless (package-installed-p 'use-package)
  (package-install 'use-package))

(require 'use-package)

(setq use-package-always-ensure t)

(setq prefix-help-command #'embark-prefix-help-command)
#+end_src
* Theme and appearance
** General
#+begin_src elisp
(setq inhibit-startup-message t)

(scroll-bar-mode -1)
(tool-bar-mode -1)
(tooltip-mode -1)
(set-fringe-mode 10)
(menu-bar-mode -1)

(setq frame-title-format
      (list (format "%s %%S: %%j " (system-name))
        '(buffer-file-name "%f" (dired-directory dired-directory "%b"))))    

(setq visible-bell t)
#+end_src

** Theme
#+begin_src elisp
(load-theme 'zenburn t)
#+end_src
** Font
#+begin_src elisp
(set-frame-font "Jetbrains Mono 14" nil t)

(global-auto-composition-mode -1)

;; Enable ligatures

;;Jetbrains ligature code from https://emacs.stackexchange.com/questions/55059/ligatures-with-the-jetbrains-mono-font
;;Works, but need to make it into a minor mode and/or incorporate it into coding modes
;;Otherwise, error b/c 'attempt to shape unibyte text'

(defconst jetbrains-ligature-mode--ligatures
  '("-->" "//" "/**" "/*" "*/" "<!--" ":=" "->>" "<<-" "->" "<-"
    "<=>" "<=" ">=" "=:=" "!==" "&&" "||" "..." ".."
    "|||" "///" "&&&" "===" "++" "--" "=>" "|>" "<|" "||>" "<||"
    "|||>" "<|||" ">>" "<<" "::=" "|]" "[|" "{|" "|}"
    "[<" ">]" ":?>" ":?" "/=" "[||]" "!!" "?:" "?." "::"
    "+++" "??" "###" "##" ":::" "####" ".?" "?=" "=!=" "<|>"
    "<:" ":<" ":>" ">:" "<>" ";;" "/==" ".=" ".-" "__"
    "=/=" "<-<" "<<<" ">>>" "<=<" "<<=" "<==" "<==>" "==>" "=>>"
    ">=>" ">>=" ">>-" ">-" "<~>" "-<" "-<<" "=<<" "---" "<-|"
    "<=|" "/\\" "\\/" "|=>" "|~>" "<~~" "<~" "~~" "~~>" "~>"
    "<$>" "<$" "$>" "<+>" "<+" "+>" "<*>" "<*" "*>" "</>" "</" "/>"
    "<->" "..<" "~=" "~-" "-~" "~@" "^=" "-|" "_|_" "|-" "||-"
    "|=" "||=" "#{" "#[" "]#" "#(" "#?" "#_" "#_(" "#:" "#!" "#="
    "&="))

(sort jetbrains-ligature-mode--ligatures (lambda (x y) (> (length x) (length y))))

(dolist (pat jetbrains-ligature-mode--ligatures)
  (set-char-table-range composition-function-table
			(aref pat 0)
			(nconc (char-table-range composition-function-table (aref pat 0))
                               (list (vector (regexp-quote pat)
                                             0
					     'compose-gstring-for-graphic)))))
     #+end_src
* Safe local variables
#+begin_src elisp
(put 'projectile-test-cmd 'safe-local-variable #'stringp)
(put 'projectile-test-cmd-prefix 'safe-local-variable #'stringp)
#+end_src
* Modes
** Ace-window
#+begin_src elisp
(use-package ace-window
  :ensure t
  :bind ("M-o" . ace-window))
#+end_src

** Meow
#+begin_src elisp
(use-package meow
  :init
  (defun insert-semicolon () 
    (interactive)
    (insert ";"))

  (defun set-meow-normal-mode-key ()
    (local-unset-key (kbd ";"))
    (global-set-key (kbd ";") 'meow-insert-exit))
  
  (global-set-key (kbd "C-M-;") 'insert-semicolon)

  :config

  ;; Remove number line hints
  (setf meow-expand-hint-remove-delay 0)
  (setq meow-keypad-leader-dispatch (kbd "C-c p"))

  (defun meow-setup ()
    (set-meow-normal-mode-key)
    (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
    (meow-motion-overwrite-define-key
     '("l" . meow-next)
     '("k" . meow-prev))
    (meow-leader-define-key
     ;; SPC j/k will run the original command in MOTION state.
     '("k" . "H-k")
     '("l" . "H-l")
     ;; Use SPC (0-9) for digit arguments.
     '("1" . meow-digit-argument)
     '("2" . meow-digit-argument)
     '("3" . meow-digit-argument)
     '("4" . meow-digit-argument)
     '("5" . meow-digit-argument)
     '("6" . meow-digit-argument)
     '("7" . meow-digit-argument)
     '("8" . meow-digit-argument)
     '("9" . meow-digit-argument)
     '("0" . meow-digit-argument)
     '("/" . meow-keypad-describe-key)
     '("?" . meow-cheatsheet))
    
    (meow-normal-define-key
     '(">" . scroll-up-command)
     '("<" . scroll-down-command)
     '("=" . pop-to-mark-command)
     '("+" . pop-global-mark)
     '("S" . save-buffer)

     '("0" . meow-expand-0)
     '("9" . meow-expand-9)
     '("8" . meow-expand-8)
     '("7" . meow-expand-7)
     '("6" . meow-expand-6)
     '("5" . meow-expand-5)
     '("4" . meow-expand-4)
     '("3" . meow-expand-3)
     '("2" . meow-expand-2)
     '("1" . meow-expand-1)
     '("-" . negative-argument)
     '("," . meow-inner-of-thing)
     '("." . meow-bounds-of-thing)
     '("[" . meow-beginning-of-thing)
     '("]" . meow-end-of-thing)
     '("a" . meow-append)
     '("A" . meow-open-below)
     '("b" . meow-back-word)
     '("B" . meow-back-symbol)
     '("c" . meow-change)
     '("d" . meow-delete)
     '("D" . meow-backward-delete)
     '("e" . meow-next-word)
     '("E" . meow-next-symbol)
     '("f" . meow-find)
     '("g" . meow-cancel-selection)
     '("G" . meow-grab)
     '("i" . meow-insert)
     '("I" . meow-open-above)

     '("L" . meow-next-expand)
     '("K" . meow-prev-expand)
     '("J" . meow-left-expand)
     '(":" . meow-right-expand)
     
     '("j" . meow-left)
     '(";" . meow-right)
     '("k" . meow-prev)
     '("l" . meow-next)
 
     '("m" . meow-join)
     '("n" . meow-search)
     '("o" . meow-block)
     '("O" . meow-to-block)
     '("p" . meow-yank)
     '("P" . yank-and-replace)
     '("q" . kill-current-buffer)
     '("Q" . meow-goto-line)
     '("r" . meow-replace)
     '("R" . meow-swap-grab)
     '("s" . meow-kill)
     '("t" . meow-till)
     '("u" . meow-undo)
     '("U" . meow-undo-in-selection)
     '("v" . meow-visit)
     '("V" . imenu)
     '("w" . meow-mark-word)
     '("W" . meow-mark-symbol)
     '("x" . meow-line)
     '("X" . meow-goto-line)
     '("y" . meow-save)
     '("Y" . kill-ring-save)
     '("z" . meow-pop-selection)
     '("h" . repeat)
     '("'" . meow-reverse)
     '("/" . avy-goto-char))
)
  
  (meow-setup)
  (meow-global-mode 1))
#+end_src

#+RESULTS:
: t
** Minions
#+begin_src elisp
(use-package minions
  :ensure t
  :config
  (minions-mode 1))
#+end_src
** C
#+begin_src elisp
;; add set-meow-normal-mode-key to C mode hook
(add-hook 'c-mode-hook 'set-meow-normal-mode-key)
#+end_src

** Copilot
#+begin_src elisp
(use-package editorconfig)
(use-package dash)
(use-package s)
(use-package editorconfig)

(add-to-list 'load-path "/home/ian/.emacs.d/copilot.el")

(require 'copilot)
(add-hook 'prog-mode-hook 'copilot-mode)

;; (define-key copilot-completion-map (kbd "<tab>") 'copilot-accept-completion)
#+end_src

** Babel
#+begin_src elisp
(use-package babel
  :config
  ;;Babel languages
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((R . t)
     (emacs-lisp . t)
     (python . t)
     (sql .t)
     (C . t))))
#+end_src

** Corfu
#+begin_src elisp
(use-package corfu
  :custom 
  (corfu-auto nil)
  ;; (corfu-auto-delay 1)
  :init
  (global-corfu-mode)
  (setq tab-always-indent t))

(defun my-inhibit-global-corfu-mode ()
  ;; "Counter-act global-corfu-mode."
  (add-hook 'after-change-major-mode-hook
            (lambda () (corfu-mode 0))
            :append :local))
#+end_src
   
** Dockerfile
#+begin_src elisp
(use-package dockerfile-mode
  :ensure t)
#+end_src

** docker
#+begin_src elisp
(use-package docker
  :ensure t)
#+end_src
** Org
*** General setup
#+begin_src elisp
(require 'oc-csl)

(use-package org-mode
  :ensure nil
  :hook (org-mode . org-superstar-mode)
  :bind (:map org-mode-map
	      ("C-S-p" . org-backward-heading-same-level)
	      ("C-S-n" . org-forward-heading-same-level)
	      ("C-M-p" . org-backward-paragraph)
	      ("C-M-n" . org-forward-paragraph)
	      ("M-9" . org-metaleft)
	      ("M-0" . org-metaright)
	      ("(" . org-shiftleft)
	      (")" . org-shiftright)
	      ("C-c a" . org-agenda)
	      ("C-c f" . insert-citation-needed)
	      ))

;;Default notes file for org-mode capture
(setq org-directory "/usr/org")
(setq org-default-notes-file (concat org-directory "/notes.org"))
(setq org-startup-folded t)
#+end_src
*** Appearance
#+begin_src elisp
(use-package org-modern)
(modify-all-frames-parameters
 '((right-divider-width . 40)
   (internal-border-width . 40)))
(dolist (face '(window-divider
                window-divider-first-pixel
                window-divider-last-pixel))
  (face-spec-reset-face face)
  (set-face-foreground face (face-attribute 'default :background)))
(set-face-background 'fringe (face-attribute 'default :background))

(setq
 ;; Edit settings
 org-auto-align-tags nil
 org-tags-column 0
 org-catch-invisible-edits 'show-and-error
 org-special-ctrl-a/e t
 ;; Insert new headings after point rather than after subtree
 org-insert-heading-respect-content nil

 ;; Org styling, hide markup etc.
 org-hide-emphasis-markers t
 org-pretty-entities t
 org-modern-todo t
 
 org-ellipsis "…"

 ;; Agenda styling
 org-agenda-tags-column 0
 org-agenda-block-separator ?─
 org-agenda-time-grid
 '((daily today require-timed)
   (800 1000 1200 1400 1600 1800 2000)
   " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
 org-agenda-current-time-string
 "⭠ now ─────────────────────────────────────────────────")

(setq org-todo-keywords
  '((sequence "TODO" "DONE")))

(with-eval-after-load 'org (global-org-modern-mode))
#+end_src
** ein
#+begin_src elisp
(use-package ein)
#+end_src
** Ibuffer
#+begin_src elisp
(setq ibuffer-formats 
      '((mark modified read-only " "
              (name 30 30 :left :elide) " "
              (mode 16 16 :left :elide) " "
              " " filename-and-process)))
#+end_src
** Key-chord
#+begin_src elisp
(use-package key-chord
  :config (key-chord-mode 1)
  ;; Keychords (more examples at https://www.emacswiki.org/emacs/key-chord.el)
  (setq key-chord-two-keys-delay 0.03)
  (key-chord-define-global "jk" 'dabbrev-expand)
  (key-chord-define-global "JK" 'dabbrev-expand)
  (key-chord-define-global ",." 'insert-parens)
  (key-chord-define-global ",/" 'insert-square-brackets)
  (key-chord-define-global "./" 'insert-curly-brackets)
  (key-chord-define-global "8u" 'insert-double-quotes)
  (key-chord-define-global "9u" 'insert-single-quotes)
  ;; Keychords for meow
  (key-chord-define meow-normal-state-keymap "io" 'scroll-down-command)
  (key-chord-define meow-normal-state-keymap "lk" 'scroll-up-command)
  (key-chord-define meow-normal-state-keymap "oo" 'other-window)
  ;; Keychords for copilot
  (key-chord-define copilot-mode-map "kl" 'copilot-accept-completion)
)



#+end_src
** Magit
#+begin_src elisp
(use-package magit)
#+end_src
** Marginalia
#+begin_src elisp
(use-package marginalia
  :config
  (marginalia-mode))
#+end_src
** CSV
#+begin_src elisp
(use-package csv-mode)
#+end_src
** Dired
#+begin_src elisp
(require 'dired)

;; Dired-omit-mode
(require 'dired-x)
(defun enable-dired-omit-mode () (dired-omit-mode 1))
(add-hook 'dired-mode-hook 'enable-dired-omit-mode)

(define-key dired-mode-map (kbd ".") 'dired-dotfiles-toggle)
(define-key dired-mode-map (kbd "/") 'dired-omit-mode)
(define-key dired-mode-map (kbd "K") 'dired-up-directory)
(define-key dired-mode-map (kbd "h") 'dired-do-kill-lines)
(define-key dired-mode-map (kbd "P") 'dired-prev-marked-file)
(define-key dired-mode-map (kbd "N") 'dired-next-marked-file)

(setq dired-listing-switches "-alh --group-directories-first")

(defun dired-dotfiles-toggle ()
  "Show/hide dot-files"
  (interactive)
  (when (equal major-mode 'dired-mode)
    (if (or (not (boundp 'dired-dotfiles-show-p)) dired-dotfiles-show-p) ; if currently showing
	(progn 
	  (set (make-local-variable 'dired-dotfiles-show-p) nil)
	  (message "h")
	  (dired-mark-files-regexp "^\\\.")
	  (dired-do-kill-lines))
      (progn (revert-buffer) ; otherwise just revert to re-show
	     (set (make-local-variable 'dired-dotfiles-show-p) t)))))
#+end_src
** Orderless
#+begin_src elisp
(use-package orderless
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src
** Embark
*** Embark
#+begin_src elisp
(use-package embark
  :ensure t

  :bind
  (("C-." . embark-act)         ;; pick some comfortable binding
   ("C-;" . embark-dwim)        ;; good alternative: M-.
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

  :init

  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command)

  ;; Show the Embark target at point via Eldoc.  You may adjust the Eldoc
  ;; strategy, if you want to see the documentation from multiple providers.
  ;; (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
  ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

  :config

  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))
#+end_src
*** Embark consult
#+begin_src elisp
(use-package embark-consult
  :ensure t ; only need to install it, embark loads it after consult if found
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

** Projectile
#+begin_src elisp
(use-package projectile
  :config
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
)

#+end_src
** Vertico
#+begin_src elisp
(use-package vertico
  :config
  (vertico-mode)
  (define-key vertico-map (kbd "'") 'vertico-next)
  (define-key vertico-map (kbd ";") 'vertico-previous)
  ;; set max candidates to 5 using set custom variable
  (set-custom-variable 'vertico-count 5)
  )

;; define function to go to next candidate and exit
(defun my-vertico-next ()
  (interactive)
  (vertico-next)
  (vertico-exit))

;; set to shift-return
(define-key vertico-map (kbd "<S-return>") 'my-vertico-next)
#+end_src
** ESS
*** ESS
#+begin_src elisp
(use-package ess
  :init
  (require 'ess-site)
  (require 'ess-r-mode)

  ;; written by chatGPT
(defun my-switch-to-R-process ()
  (interactive)
  (let* ((r-buffers (seq-filter (lambda (buf) 
                                  (let ((proc (get-buffer-process buf)))
                                    (when proc
                                      (string= "R" (process-name proc)))))
                                (buffer-list)))
         (num (length r-buffers))
         (current-buff-pos (cl-position (current-buffer) r-buffers)))
    (if r-buffers
        (switch-to-buffer (if current-buff-pos 
                              (nth (mod (+ current-buff-pos 1) num) r-buffers) 
                            (car r-buffers)))
      (message "No R buffers exist"))))

  (defun ess-insert-pipe ()
    ;; Insert a "%<%" symbol with smart spacing.
    (interactive)
    (cycle-spacing)
    (insert "%>%")
    (if (not (eolp))
	(cycle-spacing)))
      
  (defun ess-insert-gets ()
    ;; Insert a "<-" symbol with smart spacing.
    (interactive)
      (cond (
	     ;; If point is at the beginning of a line
	     (bolp)
	     (cycle-spacing)
	     (insert "<-")
	     (cycle-spacing)
	     (beginning-of-line))
	    
	    ;; If point is at the beginning of indentation
	    ((boip)
	     (save-excursion
	       (insert " <-")
	       (cycle-spacing)))
	    
	    ;; Else
	    (t
	     (cycle-spacing)
	     (insert "<-")
	     (cycle-spacing))))

  (defun my-inferior-ess-init ()
    (setq-local ansi-color-for-comint-mode 'filter))

  ;; Start R processes with the name of the active buffer
  (defun R (&optional start-args)
    (interactive "P")
    ;; Get the name of the active buffer
    (let ((buffer-name (buffer-name)))
      ;; Start the R process
      (set-buffer (run-ess-r start-args))
      ;; Rename the process buffer based on the active buffer's name
      (rename-buffer (concat "*R: " buffer-name "*") t)))

  
  :config
  (setq ess-history-file nil)
  (define-key ess-r-mode-map (kbd "C-M-p") 'ess-insert-pipe)
  (define-key ess-r-mode-map (kbd "C-'") 'ess-insert-gets)
  (define-key inferior-ess-r-mode-map (kbd "C-M-p") 'ess-insert-pipe)
  (define-key inferior-ess-r-mode-map (kbd "C-'") 'ess-insert-gets)

  ;; :bind (:map ess-r-mode
  ;;  	      ("C-M-p" . mp-ess-insert-pipe))
  :hook (inferior-ess-r-mode . my-inferior-ess-init)
  :hook (ess-mode . auto-composition-mode)
  :hook ((ess-mode . (lambda ()
                      (flymake-mode 0)
                      (setq ess-use-flymake nil)
                      (flycheck-mode 0)
                      ))))

  ;; :hook (ess-mode . flycheck-mode)

#+end_src

#+RESULTS:
| flycheck-mode | auto-composition-mode |
|               |                       |
** Org-cite
#+begin_src elisp
(require 'oc-csl)
(setq org-cite-insert-processor 'basic)
(setq org-cite-follow-processor 'bibtex)
(setq org-cite-activate-processor 'bibtex)
#+end_src
** Pyvenv
#+begin_src elisp
(use-package pyvenv
  :ensure t
  :config
  (pyvenv-mode 1)
  (setenv "WORKON_HOME" "/home/ian/miniconda3/envs/")
  (add-hook 'projectile-after-switch-project-hook 'pyvenv-auto-workon))

(defun pyvenv-auto-workon ()
  "Automatically call pyvenv-workon."
  (when projectile-project-venv-name
    (pyvenv-workon projectile-project-venv-name)))
#+end_src
** vterm
#+begin_src elisp
  (use-package vterm
    :ensure t)

  (defun get-file-vterm-name ()
    "Get vterm buffer name based on current file."
    (format "*vterm-%s*" (file-name-base (buffer-file-name))))

  (defun create-or-get-file-vterm ()
    "Create or switch to a vterm buffer named after current file."
    (interactive)
    (let ((vterm-name (get-file-vterm-name)))
      (if (get-buffer vterm-name)
	  (switch-to-buffer-other-window vterm-name)
	(progn 
	  (split-window-right)
	  (other-window 1)
	  (vterm vterm-name)))))

  (define-key vterm-mode-map (kbd "`") 'vterm-copy-mode)
  (define-key vterm-copy-mode-map (kbd "`") 'vterm-copy-mode)

  (defun vterm-copy-mode-rename-buffer ()
    "Update buffer name based on vterm-copy-mode state and handle meow modes."
    (let ((current-name (buffer-name)))
      (if vterm-copy-mode
	  (progn
	    (unless (string-match-p "^<.*>$" current-name)
	      (rename-buffer (format "<%s>" current-name)))
	    (meow-normal-mode 1))
	(progn
	  (when (string-match "^<\\(.*\\)>$" current-name)
	    (let ((name-without-brackets (match-string 1 current-name)))
	      (when name-without-brackets
		(rename-buffer name-without-brackets))))
	  (meow-insert-mode 1)))))

  (add-hook 'vterm-copy-mode-hook #'vterm-copy-mode-rename-buffer)
#+end_src
** YAML
#+begin_src elisp
(use-package yaml-mode)
#+end_src
** hydra
#+begin_src elisp
(use-package hydra)

(defhydra hydra-buffer-switch (:exit t)
  "Buffer Switch"
  ("f" switch-to-file-buffer "files")
  ("p" switch-to-process-buffer "processes")
  ("b" switch-to-buffer "all buffers")
  ("s" switch-to-special-buffer "special")
  ("d" switch-to-dired-buffer "dired")
  ("r" (switch-to-buffer nil) "most recent")
  ("R" (ibuffer-recent) "by recency")
  ("i" ibuffer "ibuffer")
  ("q" nil "quit")
)

(global-set-key (kbd "C-x b") 'hydra-buffer-switch/body)
#+end_src
* Functions

** Insertion commands
#+begin_src elisp
(defun insert-curly-brackets ()
  "Insert parentheses and place cursor between them."
  (interactive)
  (insert-sandwich-or-surround "{" "}"))

(defun insert-parens ()
  "Insert parentheses and place cursor between them."
  (interactive)
  (insert-sandwich-or-surround "(" ")"))

(defun insert-square-brackets ()
  "Insert square brackets and place cursor between them."
  (interactive)
  (insert-sandwich-or-surround "[" "]"))

(defun insert-single-quotes ()
  "Insert single quotes and place cursor between them."
  (interactive)
  (insert-sandwich-or-surround "'" "'"))

(defun insert-double-quotes ()
  "Insert double quotes and place cursor between them."
  (interactive)
  (insert-sandwich-or-surround "\"" "\""))

(defun insert-sandwich (pre post)
  "Insert a and b and place cursor between them."
  (insert pre)
  (insert post)
  (backward-char))

(defun insert-sandwich-or-surround (pre post)
  (interactive)
  (if mark-active
      (surround-region pre post)
    (insert-sandwich pre post))
  )

(defun surround-region (pre post)
  "Insert pre before region and post after."
    (let (beginning end)
      (setq beginning (min (point) (mark)))
      (setq end (max (point) (mark)))
      (goto-char beginning)
      (insert pre)
      (goto-char (+ end 1))
      (insert post))
  )

(defun insert-dash ()
  ;; Necessary to replaced hyphen keybinding for some modes; see insert-delimeter
  (interactive)
  (insert "-"))

(defun insert-delimiter ()
  ;; Insert a delimiter based on mode (e.g. hyphen for emacs lisp, underscore for Python)
  (interactive)
  (let ((delim "-")
	(underscore-modes '(python-mode
			    ess-r-mode
			    inferior-ess-r-mode)))
    (if (member major-mode underscore-modes)
	(setq delim "_"))
    (insert delim)))

(defun insert-citation-needed ()
  ;; Insert a flag indicating that a citation is needed
  (interactive)
  (let ((flag (propertize "[CN]" 'font-lock-face '(:foreground "orange"))))
    (insert flag))
  )
#+end_src
** Util
#+begin_src elisp
(defun init ()
  ;; Reload init file
  (interactive)
  (save-excursion
    (load-file (buffer-file-name (find-init)))))

(defun boip ()
  ;; Check if point is at the beginning of indentation
  (let ((old-point (point))
	new-point
	ans)
    (save-excursion
      (back-to-indentation)
      (setq new-point (point)))
    (if (equal old-point new-point)
	(setq ans t))
    ans))

(defun yank-and-replace (prefix)
  "Yank using either yank or counsel-yank-pop, then replace
string FROM with string TO in the yanked material."
  (interactive "P")
  (let ((old-point (point))
	from
	to)

    ;; yank method depends on presence of prefix:
    ;; with prefix, choose yank in minibuffer;
    ;; without, yank last kill
    (if prefix (yank-pop) (meow-yank))

    ;; read the strings to replace after the yank
    (setq from (read-string "Replace: ")
	  to (read-string "With: "))

    ;; replace the strings
    (save-excursion
      (save-restriction
	(narrow-to-region old-point (point))
	(goto-char (point-min))
	(while (search-forward from nil t)
	  (replace-match to nil t))))))
#+end_src
** Launchers
#+begin_src elisp
(defun launch-aider ()
  "Launch aider in a vterm window using default config"
  (interactive)
  (let* ((project-name (projectile-project-name))
         (buffer-name (format "*aider: %s*" project-name))
         (vterm-buffer (vterm buffer-name)))
    (with-current-buffer vterm-buffer
      (vterm-send-string "aider --config ~/.aider/.aider.conf.yml")
      (vterm-send-return))))
#+end_src
** Copy buffer path
Show path of file in buffer at modeline, copy to kill ring
#+begin_src elisp
(defun show-file-name ()
  "Show the full path file name in the minibuffer."
  (interactive)
  (message (buffer-file-name))
  (kill-new (file-truename buffer-file-name))
  )
#+end_src
** Buffer switching
#+begin_src elisp
(defun get-buffer-display-name (buffer display-fn)
  "Get display name for BUFFER using DISPLAY-FN to format extra info."
  (let ((name (buffer-name buffer))
        (extra (funcall display-fn buffer)))
    (if extra
        (format "%s (%s)" name extra)
      name)))

(defun switch-to-buffer-filtered (filter-fn display-fn prompt)
  "Switch to buffer matching FILTER-FN, displaying extra info with DISPLAY-FN.
FILTER-FN takes a buffer and returns non-nil if it should be included.
DISPLAY-FN takes a buffer and returns string of extra info (or nil if none)."
  (interactive)
  (let* ((matching-buffers (cl-remove-if-not filter-fn (buffer-list)))
         (buffer-names (mapcar (lambda (buf) 
                               (get-buffer-display-name buf display-fn))
                             matching-buffers))
         (name-to-buffer (cl-mapcar #'cons buffer-names matching-buffers))
         (selected-name (completing-read prompt buffer-names nil t)))
    (when selected-name
      (switch-to-buffer (cdr (assoc selected-name name-to-buffer))))))

;; Define specific buffer switchers using the generic function
(defun switch-to-file-buffer ()
  "Switch to a buffer visiting a file."
  (interactive)
  (switch-to-buffer-filtered 
   #'buffer-file-name
   (lambda (buf) (abbreviate-file-name (buffer-file-name buf)))
   "Switch to file buffer: "))

(defun switch-to-process-buffer ()
  "Switch to a buffer with an associated process."
  (interactive)
  (switch-to-buffer-filtered 
   (lambda (buf) 
     (and (get-buffer-process buf)
          (not (string-match-p "copilot" (downcase (buffer-name buf))))))
   (lambda (buf) (process-name (get-buffer-process buf)))
   "Switch to process buffer: "))

(defun switch-to-dired-buffer ()
  "Switch to a dired buffer."
  (interactive)
  (switch-to-buffer-filtered 
   (lambda (buf) 
     (with-current-buffer buf (eq major-mode 'dired-mode)))
   (lambda (buf) 
     (with-current-buffer buf 
       (abbreviate-file-name default-directory)))
   "Switch to dired buffer: "))

(defun switch-to-special-buffer ()
  "Switch to a special buffer."
  (interactive)
  (switch-to-buffer-filtered
   (lambda (buf)
     (let ((name (buffer-name buf)))
       (and (string-prefix-p "*" name)
            (string-suffix-p "*" name))))
   (lambda (_buf) nil)  ; no extra display info needed
   "Switch to special buffer: "))

(defun ibuffer-recent ()
  "Open ibuffer with buffers sorted by most recent first."
  (interactive)
  (ibuffer nil "*Buffers*")
  (ibuffer-do-sort-by-recency))

(defun switch-to-last-buffer ()
  "Switch to the most recently visited buffer."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer))))

#+end_src
** Find init file
#+begin_src elisp
(defun find-init ()
  (interactive)
  (find-file user-init-file))
#+end_src
** Evaluate elisp
#+begin_src elisp
(defun eval-region-confirm ()
  "Eval region in emacs lisp and send a confirmation message."
  (interactive)
  (eval-region (region-beginning) (region-end))
  (message "Evaluated."))

    ;;; Stefan Monnier <foo at acm.org>. It is the opposite of fill-paragraph    
(defun unfill-paragraph (&optional region)
  "Takes a multi-line paragraph and makes it into a single line of text."
  (interactive (progn (barf-if-buffer-read-only) '(t)))
  (let ((fill-column (point-max))
        ;; This would override `fill-column' if it's an integer.
        (emacs-lisp-docstring-fill-column t))
    (fill-paragraph nil region)))
#+end_src

* Global key bindings
#+begin_src elisp
(define-key emacs-lisp-mode-map (kbd "<C-return>") 'eval-region-confirm)
;; (global-set-key (kbd "M-i") 'imenu)
;; (global-set-key (kbd "M-O") 'ace-window)
;; (global-set-key (kbd "M-o") 'other-window)

;; Normally, suspend frame
(global-set-key (kbd "C-z") 'switch-to-last-buffer)

(global-set-key (kbd "-") 'insert-delimiter)
(global-set-key (kbd "C--") 'insert-dash)

(global-set-key (kbd "C-x /") 'global-copilot-mode)

;; (global-set-key (kbd "M-S-q") 'unfill-paragraph)

;; (global-set-key (kbd "C-c c") 'counsel-org-capture)
;; (global-set-key (kbd "C-x b") 'ivy-switch-buffer) 
;; (global-set-key (kbd "C-c z") 'counsel-fzf)

;; (global-set-key (kbd "C-c C-b") 'eval-buffer)

;; (global-set-key (kbd "C-c B") 'list-bookmarks)
(global-set-key (kbd "C-c n") 'show-file-name)
(global-set-key (kbd "C-x K") 'kill-current-buffer)
(global-set-key (kbd "C-;") 'comment-line)
;; (global-set-key (kbd "C-x ;") 'comment-or-uncomment-region)
;; (global-set-key (kbd "C-x C-;") 'comment-box)
;; (global-set-key (kbd "C-0") 'end-of-buffer)
;; (global-set-key (kbd "C-9") 'beginning-of-buffer)
(global-set-key (kbd "C-x C-p") 'replace-string)

(global-set-key (kbd "C-x X") 'compile)
(global-set-key (kbd "C-x C-g") 'revert-buffer)

;; (global-set-key (kbd "C-M-y") 'counsel-yank-pop)

(global-set-key (kbd "M-n") 'forward-paragraph)
(global-set-key (kbd "M-p") 'backward-paragraph)

(global-set-key (kbd "C-x C-b") 'ibuffer)

;; (global-set-key (kbd "C-S-d") 'pyvenv-restart-python)
(message "Global keys bound.")
; (global-set-key (kbd "C-x 4") 'mp-split-window-4)
#+end_src

#+RESULTS:
: Global keys bound.

* End configuration
#+begin_src elisp
(message "********************************************************************************")
(message "Initialization complete.")

(put 'narrow-to-region 'disabled nil)
(put 'upcase-region 'disabled nil)
#+end_src
* Macro settings
#+begin_src elisp
(require 'kmacro)
(defalias 'kmacro-insert-macro 'insert-kbd-macro)
(define-key kmacro-keymap (kbd "I") 'kmacro-insert-macro)
#+end_src
